# TypeScript Generation from Python Dataclasses

Generate TypeScript interfaces from Python dataclasses for end-to-end type safety when using colight-serde.

## The Problem

You have Python dataclasses that get serialized and sent to JavaScript:

```python
@dataclass
class Pose:
    posquat: NDArray[np.float32]  # shape: [7] - position + quaternion

@dataclass
class Scenario:
    camera_poses: Pose
    timestamps: NDArray[np.float64]
```

On the JavaScript side, you're working with `any` types or manually maintaining duplicate type definitions that drift out of sync.

## The Solution

Generate TypeScript interfaces directly from Python, with shape information encoded in the types:

```python
from dataclasses import dataclass
from typing import Annotated
import numpy as np
from numpy.typing import NDArray
from colight_serde.typescript import Shape, register_ts_interfaces, generate_typescript

@dataclass
class Pose:
    posquat: Annotated[NDArray[np.float32], Shape(7)]  # fixed [7]

@dataclass
class Trajectory:
    posquats: Annotated[NDArray[np.float32], Shape(None, 7)]  # [number, 7]
    timestamps: Annotated[NDArray[np.float64], Shape(None)]   # [number]

@dataclass
class Scenario:
    camera_trajectory: Trajectory
    object_trajectory: Trajectory
    labels: list[str]

register_ts_interfaces(Pose, Trajectory, Scenario)
print(generate_typescript())
```

Output:
```typescript
// Auto-generated by colight-serde. Do not edit manually.

import type { NdArrayView } from "@colight/serde";

export interface Pose {
  posquat: NdArrayView<Float32Array, [7]>;
}

export interface Trajectory {
  posquats: NdArrayView<Float32Array, [number, 7]>;
  timestamps: NdArrayView<Float64Array, [number]>;
}

export interface Scenario {
  camera_trajectory: Trajectory;
  object_trajectory: Trajectory;
  labels: string[];
}
```

## Shape Annotations

Use `Annotated` with `Shape(...)` to encode array dimensions:

```python
from typing import Annotated
from colight_serde.typescript import Shape

@dataclass
class Example:
    # Fixed shape [7]
    vec7: Annotated[NDArray[np.float32], Shape(7)]

    # Dynamic first dim, fixed second: [number, 3]
    points: Annotated[NDArray[np.float32], Shape(None, 3)]

    # 4x4 matrix
    transform: Annotated[NDArray[np.float32], Shape(4, 4)]

    # Fully dynamic shape (just NdArrayView<Float32Array>)
    raw: NDArray[np.float32]
```

Generated TypeScript:
```typescript
export interface Example {
  vec7: NdArrayView<Float32Array, [7]>;
  points: NdArrayView<Float32Array, [number, 3]>;
  transform: NdArrayView<Float32Array, [4, 4]>;
  raw: NdArrayView<Float32Array>;
}
```

### Shape Syntax

| Python | TypeScript | Meaning |
|--------|------------|---------|
| `Shape(7)` | `[7]` | Fixed 1D array of 7 elements |
| `Shape(3, 4)` | `[3, 4]` | Fixed 3×4 matrix |
| `Shape(None)` | `[number]` | Dynamic length 1D |
| `Shape(None, 7)` | `[number, 7]` | Batch of 7-vectors |
| `Shape(None, None, 3)` | `[number, number, 3]` | Dynamic H×W×3 image |

## Usage in TypeScript

The generated types provide IDE support and type-safe indexed access:

```typescript
import type { Scenario, Trajectory } from "./generated-types";
import type { NdArrayView } from "@colight/serde";
import { unpackMessage } from "@colight/serde";

// Receive and unpack with full type safety
const scenario: Scenario = unpackMessage(envelope, buffers).payload;

// Types flow through
const traj: Trajectory = scenario.camera_trajectory;
const posquats = traj.posquats;  // NdArrayView<Float32Array, [number, 7]>

// Typed indexed access
const firstPose = posquats[0];   // NdArrayView<Float32Array, [7]>
const x = firstPose[0];          // number (x position)
const qw = firstPose[3];         // number (quaternion w)

// Or chain directly
const y = posquats[0][1];        // number

// Properties
posquats.data;     // Float32Array
posquats.shape;    // [number, 7]
posquats.ndim;     // 2
posquats.length;   // total elements
```

## API

### Registering Types

**Decorator (for types you define):**
```python
from colight_serde.typescript import ts_interface

@ts_interface
@dataclass
class MyType:
    value: float
```

**Function (for external types):**
```python
from colight_serde.typescript import register_ts_interfaces

# Types from libraries you don't control
from vision import Pose
from vision.sparse.scenario import Scenario

register_ts_interfaces(Pose, Scenario)
```

### Generating Output

```python
from colight_serde.typescript import generate_typescript, write_typescript

# Get as string
ts_code = generate_typescript()

# Write to file
write_typescript("src/generated/types.d.ts")
```

## Type Mappings

| Python | TypeScript |
|--------|------------|
| `int`, `float` | `number` |
| `str` | `string` |
| `bool` | `boolean` |
| `bytes` | `ArrayBuffer` |
| `list[T]` | `T[]` |
| `dict[str, T]` | `{ [key: string]: T }` |
| `tuple[A, B, C]` | `[A, B, C]` |
| `Optional[T]` | `T \| null` |
| `Union[A, B]` | `A \| B` |
| `Literal["a", "b"]` | `"a" \| "b"` |
| `NDArray[np.float32]` | `NdArrayView<Float32Array>` |
| `Annotated[NDArray[np.float32], Shape(7)]` | `NdArrayView<Float32Array, [7]>` |
| Registered dataclass | Interface reference |

### Dtype Mappings

| NumPy dtype | TypeScript TypedArray |
|-------------|----------------------|
| `np.float32` | `Float32Array` |
| `np.float64` | `Float64Array` |
| `np.int8` | `Int8Array` |
| `np.int16` | `Int16Array` |
| `np.int32` | `Int32Array` |
| `np.int64` | `BigInt64Array` |
| `np.uint8` | `Uint8Array` |
| `np.uint16` | `Uint16Array` |
| `np.uint32` | `Uint32Array` |
| `np.uint64` | `BigUint64Array` |

## Limitations

### Shape is Documentation, Not Enforcement

TypeScript can express the shape in types, but cannot enforce array lengths at runtime:

```typescript
// TypeScript knows the expected shape
const vec: NdArrayView<Float32Array, [7]> = ...;

// But this compiles fine even though it's wrong
const wrongVec: NdArrayView<Float32Array, [7]> = someOther3DVector;
```

The shape types provide:
- IDE autocomplete showing expected shapes
- Documentation in types
- Correct return types for indexed access (`vec[0]` → `number`)

### External Types Without Shape

When registering external dataclasses that don't use `Annotated[..., Shape(...)]`, arrays will be typed as `NdArrayView<DType>` without shape info:

```python
# External library type (you can't modify it)
@dataclass
class ExternalPose:
    posquat: NDArray[np.float32]  # no Shape annotation

register_ts_interfaces(ExternalPose)
# Generates: posquat: NdArrayView<Float32Array>;
```

## Build Integration

```python
# scripts/generate_types.py
from colight_serde.typescript import write_typescript, register_ts_interfaces
from myapp.models import Scenario, Pose, Frame

register_ts_interfaces(Scenario, Pose, Frame)
write_typescript("src/generated/types.d.ts")
```

```json
// package.json
{
  "scripts": {
    "generate-types": "python scripts/generate_types.py",
    "prebuild": "npm run generate-types"
  }
}
```
